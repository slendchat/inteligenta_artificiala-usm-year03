# Лаба 7 — классическая задача двух кружек

Реализовал модель пространства состояний для двух кружек 4л и 3л в каталоге `src/juglab`.

## Что внутри проекта

- `juglab/state.py` — тут описан `JugState`, то есть состояние вида `(big, small)` и все правила переходов (налить, вылить, перелить). Я ещё сделал генерацию полного графа состояний и карту предков для обратного поиска.
- `juglab/search.py` — разные алгоритмы: BFS, DFS, жадный, A*, обратный BFS и смешанный (сначала немного BFS, потом Greedy). Каждый возвраащает `SearchResult` с путём, действиями, количеством посещённых узлов и временем.
- `juglab/heuristics.py` — несколько эвристик. Основная — разница по литрам в большой кружке, но очень аккуратно (делю на 2), чтобы быть допустимой.
- `juglab/analysis.py` — вспомогательные функции: проверка эвристики на допустимость/согласованность и таблица сравнения стратегий.
- `juglab/visualization.py` — строит граф переходов в формате DOT и красиво печатает путь.
- `juglab/ui.py` + `__main__.py` — консольный интерфейс, чтобы не запускать каждый алгоритм руками. Есть меню, можно переключать эвристику, валидировать её и экспортировать график.
- `tests/test_juglab.py` — три теста на генерацию переходов, BFS и эвристику.

## Как запускать

1. Активируйте виртуальное окружение (я использую `.venv`).  
   ```bash
   source .venv/bin/activate
   ```
2. Добавьте пакет в `PYTHONPATH`, чтобы интерпретатор видел `juglab`.  
   ```bash
   export PYTHONPATH=$(pwd)/lab07/src
   ```
3. Запуск UI:  
   ```bash
   python -m juglab
   ```
   Дальше в меню выбираете стратегию. Пример: цифра `1` — это BFS, покажет последовательность шагов, сколько состояний посещено и т.д.  
   Пункт `8` сохраняет граф в `jug_graph.dot`, а `9` проверяет выбраную эвристику. Пункт `10` даёт выбрать другую эвристику из списка.

## Как всё работает внутри

1. **Формализация**. Состояние — это `JugState(big, small)` с проверкой, что объёмы не выходят за 0..4 и 0..3. Цель: `big == 2`, второе значение любое.  
2. **Операторы**. Функция `successors` в `state.py` возвращает список `Transition`. Это и есть таблица правил: налить, вылить, перелить 4→3 и 3→4. Каждое действие стоит 1.
3. **Поиск**. В `search.py` каждая стратегия строит путь через словарь `parents`. Когда найдена цель, `_reconstruct_path` собирает последовательность состояний и действий.  
   - `breadth_first_search` гарантирует минимальное количество шагов (для нас это 6 действии).  
   - `depth_first_search` умеет работать с ограничением глубины (у меня 10 по умолчанию).  
   - `greedy_best_first_search` и `a_star_search` берут эвристику и используют кучу `heapq`.  
   - `backward_bfs` строит путь от всех целевых состояний назад к `(0,0)` через предковую карту.  
   - `mixed_strategy` сначала делает пару уровней BFS, потом для каждого фронтирного узла запускает жадный поиск — такая гибридная штука для исследовательской части.
4. **Эвристика**. В `heuristics.py` считаю `abs(big-2)//2`. Почему так? Потому что за одно действие максимум может измениться 2 литра в большой кружке. В `analysis.evaluate_heuristic` бегу по всем состояниям графа и проверяю условия допустимости/согласованности.
5. **Визуализация**. `visualization.export_graphviz` создаёт DOT-файл. Можно потом `dot -Tpng jug_graph.dot -o graph.png`. Путь форматируется в человекочитаемый текст.
6. **UI**. Простой цикл `while True`, который печатает меню и вызывает функции из `search` и `analysis`. Это нужно для демонстрации на защите.

## Тесты

```bash
PYTHONPATH=lab07/src python -m unittest discover -s lab07/src/tests
```

Там проверяется, что из `(0,0)` доступны две операции, BFS реально находит решение за 6 шагов, а эвристика адекватная.

## Как использовать в отчёте

- Таблица правил берётся прямо из `state.successors`, можно переписать в красивый вид.  
- Последовательность состояний и действий копирую из вывода UI после запуска нужного метода.  
- Таблица сравнения стратегий генерируется командой `analysis.format_results_table(analysis.run_strategy_suite())`.  
- Граф переходов вставляю в отчёт как картинку.

Проект показывает все части задания: формализация пространства, разные стратегии (слепые и эвристические), исследовательская часть (обратный поиск + смешанная стратегия + граф).
